# 람다 대수 튜토리얼

- 라울 로하스

ㅅ-캘큘러스는 _세상에서 가장 작은 전역 프로그래밍 언어_ 라고 부를 수 있다.

ㅅ-캘큘러스는 단일 함수 정의 스키마와 단일 변환 규칙 (가변 대치는 베타 변환이라고도 부른다).
이는 1930년대에 앨론조 처치가 효율적인 계산 가능성의 개념을 공식화하는 과정에서 도입했다.

ㅅ-캘큘러스는 이 형식을 이용하여 계산 가능한 모든 함수를 표현하고 평가할 수 있다는 점에서 보편적이다.
따라서 이는 튜링 머신과 동등하다. (처치-튜링 정리)
그러나 ㅅ-캘큘러스는 기호 변환 규칙을 사용한다는 것을 강조하고 실제 기계 구현에는 신경쓰지 않는다.
이는 하드웨어보다 소프트웨어에 더 관련된 접근법이다.

ㅅ-캘큘러스의 핵심 개념은 '표현'이다. '이름'은 우리의 목적에 의해 아무 낱말이나 될 수 있는 구별자이다.
'표현'은 그냥 이름이나 함수가 될 수 있다. 함수는 그리스 알파벳 람다를 이용하여 인자의 이름을 표시한다.
함수의 몸체는 인자가 어떻게 재배치되는지 나타낸다. 예를 들어 항등 함수는 ㅅx.x 와 같이 나타낸다.
ㅅx는 함수의 인자가 x라는 것을, .이후의 x는 함수가 인자로 받은 x를 그대로 반환한다는 것을 의미한다.

함수는 다른 함수에 적용될 수 있다.
예를 들어 함수 A는 함수 B에 적용될 수 있다.
이는 AB 와 같이 표현된다. 이후로도 대문자는 함수를 의미한다.
사실, ㅅ-캘큘러스에서 관심있는 모든 것들은 함수이다.
숫자나 논리적 값들도 기호 문자열을 다른 문자열로 변환하기 위해 서로 적용할 수 있는 함수의 형태로 표시된다.
ㅅ-캘큘러스에는 타입이 없다.
모든 함수는 모든 것들에 적용이 가능하다.
프로그래머는 계산을 합리적으로 유지할 책임이 있다.

expression은 재귀적으로 다음과 같다.
expr := name | function | application
function := ㅅname.expression
application := expression expression

표현은 명시성을 위해 괄호로 감쌀 수 있다. E는 (E) 와 같다.
application은 좌결합성을 띈다.

ㅅx.x === (ㅅx.x) 이다.
=== 는 양변이 동의어라는 의미이다.
ㅅ 오른쪽에 오는이름은 이 함수의 인자들의 식별자이다.
. 이후에 오는 것들은 이 함수의 정의의 '몸'이라 불리는 것이다.

함수는 표현에 적용될 수 있다.

## 자유변수와 묶인 변수

람다 대수에서 모든 이름은 정의 내에서만 묶여있다.

ㅅx.x 의 x에 해당
ㅅx.xy 에서 y는 이 스코프 안에서 묶여있지 않기 때문에 자유변수라 한다.

다음의 경우에 해당하면 자유변수이다

- 이름은 이름에서 자유변수이다
- 이름 != 이름 이면서 name이 expr 안에서 자유변수일 때, 이름은 ㅅ이름.expr 안에서 자유변수이다.
- 이름이 E_1 안에서 자유변수이거나 E_2 안에서 자유변수라면, 이름E_1E_2 안에서 자유변수이다.

다음의 경우에 해당하면 묶인 변수이다.

- 이름=이름1 이거나 이름이 expr에 묶여있을 때, 이름은 ㅅ이름1.expr에 묶인 변수이다.
  (x는 ㅅy.(ㅅx.x)) 에서 묶인 변수
- 이름이 E_1 에 묶여있거나, E_2에 묶여있을 때 이름은 E_1E_2에 묶인 변수이다.

(ㅅx.xy)(ㅅy.y) 에서 y는 앞의 식에서 자유변수이므로 자유변수이다. 그러나 뒤의 expr에서는 묶인 변수이다.
따라서 y는 이 전체 expr 에서 묶여있기도, 자유이기도 하다.

## 산술연산

람다대수에서는 숫자도 함수이다.

0 === ㅅs.(ㅅz.z)

0 === ㅅsz.z

1 === ㅅsz.s(z)

2 === ㅅsz.s(s(z))

3 === ㅅsz.s(s(s(z)))

즉, 후위에 오는 함수를 n 회차 거듭먹인다는 것.

반면 zero function 은 false combinator (Kite-combinator), s를 적용하지 않은 z를 그대로 반환

### 계승자 함수 S

S === ㅅnab.a(nab)

S(0) === 1

S0 === (ㅅnab.a(nab))0
S0 === (ㅅab.a(0ab))
S0 === (ㅅab.a(b))
S0 === 1

S(1) === 2

### 덧셈

a + b 는 aSb 이다. (즉 b에 1을 더하는 것을 a번 하면 되는것)

### 곱셈

두 숫자의 곱셈은 다음과 같다.

(ㅅxya.x(ya))

3 \* 4 는

(ㅅxya.x(ya))34

ㅅa.3(4a)

### 조건문

Kestrel Combinator = true

T === ㅅxy.x

Kite Combinator = false

F === ㅅxy.y

Sxyz = xz(yz)
